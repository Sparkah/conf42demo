"""
GitHub webhook handler for automatic PR review.
"""

import hashlib
import hmac
import os
import httpx
from fastapi import FastAPI, Request, HTTPException, BackgroundTasks
from pydantic import BaseModel

from src.reviewer.code_reviewer import CodeReviewer


app = FastAPI(title="AI Engineering Quality - GitHub Integration")

# GitHub configuration
GITHUB_WEBHOOK_SECRET = os.getenv("GITHUB_WEBHOOK_SECRET", "")
GITHUB_TOKEN = os.getenv("GITHUB_TOKEN", "")


class WebhookPayload(BaseModel):
    """Simplified webhook payload."""
    action: str | None = None
    number: int | None = None
    pull_request: dict | None = None
    repository: dict | None = None


def verify_signature(payload: bytes, signature: str) -> bool:
    """Verify GitHub webhook signature."""
    if not GITHUB_WEBHOOK_SECRET:
        return True  # Skip verification if no secret configured (dev mode)

    expected = "sha256=" + hmac.new(
        GITHUB_WEBHOOK_SECRET.encode(),
        payload,
        hashlib.sha256
    ).hexdigest()

    return hmac.compare_digest(expected, signature)


async def get_pr_diff(owner: str, repo: str, pr_number: int) -> str:
    """Fetch PR diff from GitHub."""
    url = f"https://api.github.com/repos/{owner}/{repo}/pulls/{pr_number}"

    headers = {
        "Accept": "application/vnd.github.v3.diff",
        "Authorization": f"Bearer {GITHUB_TOKEN}" if GITHUB_TOKEN else "",
    }

    async with httpx.AsyncClient() as client:
        response = await client.get(url, headers=headers)
        if response.status_code == 200:
            return response.text[:15000]  # Limit diff size
        return ""


async def get_pr_files(owner: str, repo: str, pr_number: int) -> list[dict]:
    """Fetch list of changed files in PR."""
    url = f"https://api.github.com/repos/{owner}/{repo}/pulls/{pr_number}/files"

    headers = {
        "Accept": "application/vnd.github.v3+json",
        "Authorization": f"Bearer {GITHUB_TOKEN}" if GITHUB_TOKEN else "",
    }

    async with httpx.AsyncClient() as client:
        response = await client.get(url, headers=headers)
        if response.status_code == 200:
            return response.json()
        return []


async def post_pr_comment(owner: str, repo: str, pr_number: int, body: str):
    """Post a comment on a PR."""
    url = f"https://api.github.com/repos/{owner}/{repo}/issues/{pr_number}/comments"

    headers = {
        "Accept": "application/vnd.github.v3+json",
        "Authorization": f"Bearer {GITHUB_TOKEN}",
    }

    async with httpx.AsyncClient() as client:
        response = await client.post(url, headers=headers, json={"body": body})
        return response.status_code == 201


def format_review_comment(result, pr_title: str, files_changed: int) -> str:
    """Format review result as GitHub markdown comment."""

    # Risk badge color
    if result.risk_score <= 30:
        risk_badge = "üü¢"
        risk_label = "Low Risk"
    elif result.risk_score <= 60:
        risk_badge = "üü°"
        risk_label = "Medium Risk"
    else:
        risk_badge = "üî¥"
        risk_label = "High Risk"

    # Quality badge
    if result.quality_score >= 70:
        quality_badge = "üü¢"
    elif result.quality_score >= 40:
        quality_badge = "üü°"
    else:
        quality_badge = "üî¥"

    # Recommendation
    rec_map = {
        "approve": "‚úÖ **APPROVE**",
        "needs_discussion": "üí¨ **NEEDS DISCUSSION**",
        "request_changes": "‚ùå **REQUEST CHANGES**",
    }
    recommendation = rec_map.get(result.merge_recommendation, "üí¨ **REVIEW**")

    comment = f"""## ü§ñ AI Code Review

{recommendation}

| Metric | Score |
|--------|-------|
| {risk_badge} Risk | **{result.risk_score:.0f}/100** ({risk_label}) |
| {quality_badge} Quality | **{result.quality_score:.0f}/100** |
| üìÅ Files Changed | {files_changed} |

### Summary
{result.summary}

"""

    # Add issues if any
    if result.issues:
        comment += "### Issues Found\n\n"

        for issue in result.issues[:10]:  # Limit to 10 issues
            severity_icon = {
                "critical": "üî¥",
                "warning": "üü°",
                "suggestion": "üîµ"
            }.get(issue.severity, "‚ö™")

            comment += f"- {severity_icon} **{issue.severity.upper()}** ({issue.category}): {issue.message}\n"
            if issue.suggestion:
                comment += f"  - üí° *{issue.suggestion}*\n"

        comment += "\n"

    comment += """---
<sub>ü§ñ Generated by AI Engineering Quality Bot | [Learn more](https://github.com)</sub>
"""

    return comment


async def review_pr(owner: str, repo: str, pr_number: int, pr_title: str):
    """Review a PR and post results as comment."""

    # Get PR diff
    diff = await get_pr_diff(owner, repo, pr_number)
    files = await get_pr_files(owner, repo, pr_number)

    if not diff:
        return

    # Review the diff using LLM
    reviewer = CodeReviewer()

    # Create a mock review from diff content
    from src.utils.llm_client import get_llm_client
    import json

    llm = get_llm_client()

    prompt = f"""You are an expert code reviewer. Review this GitHub PR diff and identify issues.

## PR Title: {pr_title}
## Files Changed: {len(files)}

## Diff
```diff
{diff[:10000]}
```

## Review Instructions
1. Check for security vulnerabilities
2. Check for bugs and logic errors
3. Check for breaking changes
4. Check for missing error handling
5. Consider the impact of these changes

Provide your review in this JSON format:
{{
    "risk_score": <0-100>,
    "quality_score": <0-100>,
    "issues": [
        {{
            "severity": "<critical|warning|suggestion>",
            "category": "<security|performance|maintainability|bug|style>",
            "file": "<filename>",
            "message": "<description of issue>",
            "suggestion": "<how to fix>"
        }}
    ],
    "summary": "<1-2 sentence summary of the changes and their quality>",
    "merge_recommendation": "<approve|request_changes|needs_discussion>"
}}

Return ONLY valid JSON."""

    content = llm.complete(prompt, max_tokens=2048, temperature=0.2)

    try:
        if "```json" in content:
            content = content.split("```json")[1].split("```")[0]
        elif "```" in content:
            content = content.split("```")[1].split("```")[0]
        llm_result = json.loads(content.strip())
    except (json.JSONDecodeError, IndexError):
        llm_result = {
            "risk_score": 50,
            "quality_score": 50,
            "issues": [],
            "summary": "Unable to analyze PR",
            "merge_recommendation": "needs_discussion",
        }

    # Create result object
    from src.reviewer.code_reviewer import ReviewResult, ReviewIssue

    issues = [
        ReviewIssue(
            severity=i.get("severity", "suggestion"),
            category=i.get("category", "maintainability"),
            file=i.get("file", "unknown"),
            line=None,
            message=i.get("message", ""),
            suggestion=i.get("suggestion"),
        )
        for i in llm_result.get("issues", [])
    ]

    result = ReviewResult(
        risk_score=llm_result.get("risk_score", 50),
        quality_score=llm_result.get("quality_score", 50),
        issues=issues,
        summary=llm_result.get("summary", ""),
        merge_recommendation=llm_result.get("merge_recommendation", "needs_discussion"),
        static_metrics={},
    )

    # Format and post comment
    comment = format_review_comment(result, pr_title, len(files))
    await post_pr_comment(owner, repo, pr_number, comment)


@app.post("/webhook/github")
async def github_webhook(request: Request, background_tasks: BackgroundTasks):
    """Handle GitHub webhook events."""

    # Get raw payload for signature verification
    payload = await request.body()
    signature = request.headers.get("X-Hub-Signature-256", "")

    # Verify signature
    if GITHUB_WEBHOOK_SECRET and not verify_signature(payload, signature):
        raise HTTPException(status_code=401, detail="Invalid signature")

    # Parse event
    event_type = request.headers.get("X-GitHub-Event", "")
    data = await request.json()

    # Handle pull request events
    if event_type == "pull_request":
        action = data.get("action")

        # Only review on open or synchronize (new commits)
        if action in ("opened", "synchronize", "reopened"):
            pr = data.get("pull_request", {})
            repo = data.get("repository", {})

            owner = repo.get("owner", {}).get("login", "")
            repo_name = repo.get("name", "")
            pr_number = pr.get("number")
            pr_title = pr.get("title", "")

            if owner and repo_name and pr_number:
                # Run review in background
                background_tasks.add_task(
                    review_pr, owner, repo_name, pr_number, pr_title
                )

                return {"status": "reviewing", "pr": pr_number}

    return {"status": "ignored", "event": event_type}


@app.get("/health")
async def health():
    """Health check endpoint."""
    return {"status": "ok", "service": "ai-eng-quality"}


@app.get("/")
async def root():
    """Root endpoint with info."""
    return {
        "service": "AI Engineering Quality",
        "endpoints": {
            "/webhook/github": "GitHub webhook receiver",
            "/health": "Health check",
            "/review/pr": "Manual PR review trigger",
        }
    }


@app.post("/review/pr")
async def manual_review(owner: str, repo: str, pr_number: int, background_tasks: BackgroundTasks):
    """Manually trigger a PR review."""

    if not GITHUB_TOKEN:
        raise HTTPException(status_code=400, detail="GITHUB_TOKEN not configured")

    # Get PR info
    url = f"https://api.github.com/repos/{owner}/{repo}/pulls/{pr_number}"
    headers = {
        "Accept": "application/vnd.github.v3+json",
        "Authorization": f"Bearer {GITHUB_TOKEN}",
    }

    async with httpx.AsyncClient() as client:
        response = await client.get(url, headers=headers)
        if response.status_code != 200:
            raise HTTPException(status_code=404, detail="PR not found")
        pr_data = response.json()

    pr_title = pr_data.get("title", "")

    # Run review in background
    background_tasks.add_task(review_pr, owner, repo, pr_number, pr_title)

    return {"status": "reviewing", "pr": pr_number, "title": pr_title}
